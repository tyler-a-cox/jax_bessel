import jax
import jax.numpy as jnp
import numpy as np
from jax import jit, lax, vmap
from jax.lax import scan
from scipy import special
from jax._src import core, custom_derivatives, dtypes
from jax._src.interpreters import ad
from jax._src.lax.lax import _const as _lax_const
from jax._src.numpy.util import promote_args_inexact, promote_dtypes_inexact
from jax._src.typing import Array, ArrayLike
import functools

# jax.config.update("jax_enable_x64", True)

# polynomial coefficients for J0
PP0 = np.array(
    [
        7.96936729297347051624e-4,
        8.28352392107440799803e-2,
        1.23953371646414299388e0,
        5.44725003058768775090e0,
        8.74716500199817011941e0,
        5.30324038235394892183e0,
        9.99999999999999997821e-1,
    ]
)
PQ0 = np.array(
    [
        9.24408810558863637013e-4,
        8.56288474354474431428e-2,
        1.25352743901058953537e0,
        5.47097740330417105182e0,
        8.76190883237069594232e0,
        5.30605288235394617618e0,
        1.00000000000000000218e0,
    ]
)

QP0 = np.array(
    [
        -1.13663838898469149931e-2,
        -1.28252718670509318512e0,
        -1.95539544257735972385e1,
        -9.32060152123768231369e1,
        -1.77681167980488050595e2,
        -1.47077505154951170175e2,
        -5.14105326766599330220e1,
        -6.05014350600728481186e0,
    ]
)
QQ0 = np.array(
    [
        1.0,
        6.43178256118178023184e1,
        8.56430025976980587198e2,
        3.88240183605401609683e3,
        7.24046774195652478189e3,
        5.93072701187316984827e3,
        2.06209331660327847417e3,
        2.42005740240291393179e2,
    ]
)

YP0 = np.array(
    [
        1.55924367855235737965e4,
        -1.46639295903971606143e7,
        5.43526477051876500413e9,
        -9.82136065717911466409e11,
        8.75906394395366999549e13,
        -3.46628303384729719441e15,
        4.42733268572569800351e16,
        -1.84950800436986690637e16,
    ]
)
YQ0 = np.array(
    [
        1.04128353664259848412e3,
        6.26107330137134956842e5,
        2.68919633393814121987e8,
        8.64002487103935000337e10,
        2.02979612750105546709e13,
        3.17157752842975028269e15,
        2.50596256172653059228e17,
    ]
)

DR10 = 5.78318596294678452118e0
DR20 = 3.04712623436620863991e1

RP0 = np.array(
    [
        -4.79443220978201773821e9,
        1.95617491946556577543e12,
        -2.49248344360967716204e14,
        9.70862251047306323952e15,
    ]
)
RQ0 = np.array(
    [
        1.0,
        4.99563147152651017219e2,
        1.73785401676374683123e5,
        4.84409658339962045305e7,
        1.11855537045356834862e10,
        2.11277520115489217587e12,
        3.10518229857422583814e14,
        3.18121955943204943306e16,
        1.71086294081043136091e18,
    ]
)

# J1
RP1 = np.array(
    [
        -8.99971225705559398224e8,
        4.52228297998194034323e11,
        -7.27494245221818276015e13,
        3.68295732863852883286e15,
    ]
)
RQ1 = np.array(
    [
        1.0,
        6.20836478118054335476e2,
        2.56987256757748830383e5,
        8.35146791431949253037e7,
        2.21511595479792499675e10,
        4.74914122079991414898e12,
        7.84369607876235854894e14,
        8.95222336184627338078e16,
        5.32278620332680085395e18,
    ]
)

PP1 = np.array(
    [
        7.62125616208173112003e-4,
        7.31397056940917570436e-2,
        1.12719608129684925192e0,
        5.11207951146807644818e0,
        8.42404590141772420927e0,
        5.21451598682361504063e0,
        1.00000000000000000254e0,
    ]
)
PQ1 = np.array(
    [
        5.71323128072548699714e-4,
        6.88455908754495404082e-2,
        1.10514232634061696926e0,
        5.07386386128601488557e0,
        8.39985554327604159757e0,
        5.20982848682361821619e0,
        9.99999999999999997461e-1,
    ]
)

QP1 = np.array(
    [
        5.10862594750176621635e-2,
        4.98213872951233449420e0,
        7.58238284132545283818e1,
        3.66779609360150777800e2,
        7.10856304998926107277e2,
        5.97489612400613639965e2,
        2.11688757100572135698e2,
        2.52070205858023719784e1,
    ]
)
QQ1 = np.array(
    [
        1.0,
        7.42373277035675149943e1,
        1.05644886038262816351e3,
        4.98641058337653607651e3,
        9.56231892404756170795e3,
        7.99704160447350683650e3,
        2.82619278517639096600e3,
        3.36093607810698293419e2,
    ]
)

YP1 = np.array(
    [
        1.26320474790178026440e9,
        -6.47355876379160291031e11,
        1.14509511541823727583e14,
        -8.12770255501325109621e15,
        2.02439475713594898196e17,
        -7.78877196265950026825e17,
    ]
)
YQ1 = np.array(
    [
        5.94301592346128195359e2,
        2.35564092943068577943e5,
        7.34811944459721705660e7,
        1.87601316108706159478e10,
        3.88231277496238566008e12,
        6.20557727146953693363e14,
        6.87141087355300489866e16,
        3.97270608116560655612e18,
    ]
)

Z1 = 1.46819706421238932572e1
Z2 = 4.92184563216946036703e1
PIO4 = 0.78539816339744830962  # pi/4
THPIO4 = 2.35619449019234492885  # 3*pi/4
SQ2OPI = 0.79788456080286535588  # sqrt(2/pi)


def j1_small(x: ArrayLike) -> Array:
    """
    Implementation of J1 for x < 5
    """
    z = x * x
    w = jnp.polyval(RP1, z) / jnp.polyval(RQ1, z)
    w = w * x * (z - Z1) * (z - Z2)
    return w


def j1_large(x: ArrayLike) -> Array:
    """
    Implementation of J1 for x > 5
    """
    w = 5.0 / x
    z = w * w
    p = jnp.polyval(PP1, z) / jnp.polyval(PQ1, z)
    q = jnp.polyval(QP1, z) / jnp.polyval(QQ1, z)
    xn = x - THPIO4
    p = p * jnp.cos(xn) - w * q * jnp.sin(xn)
    return p * SQ2OPI / jnp.sqrt(x)


@jax.jit
def j1(z: ArrayLike) -> Array:
    """
    Bessel function of the first kind of order one and a real argument
    - using the implementation from CEPHES, translated to Jax, to match scipy to machine precision.

    Reference:
    Cephes mathematical library.

    Args:
        x: The sampling point(s) at which the Bessel function of the first kind are
        computed.

    Returns:
        An array of shape `x.shape` containing the values of the Bessel function
    """

    z = jnp.asarray(z)
    (z,) = promote_dtypes_inexact(z)
    z_dtype = lax.dtype(z)

    if dtypes.issubdtype(z_dtype, complex):
        raise ValueError("complex input not supported.")

    return jnp.sign(z) * jnp.where(
        jnp.abs(z) < 5.0, j1_small(jnp.abs(z)), j1_large(jnp.abs(z))
    )


def j0_small(x: ArrayLike) -> Array:
    """
    Implementation of J0 for x < 5
    """
    z = jnp.square(x)
    p = (z - DR10) * (z - DR20)
    p = p * jnp.polyval(RP0, z) / jnp.polyval(RQ0, z)
    return jnp.where(x < 1e-5, 1 - z / 4.0, p)


def j0_large(x: ArrayLike) -> Array:
    """
    Implementation of J0 for x >= 5
    """

    w = 5.0 / x
    q = 25.0 / jnp.square(x)
    p = jnp.polyval(PP0, q) / jnp.polyval(PQ0, q)
    q = jnp.polyval(QP0, q) / jnp.polyval(QQ0, q)
    xn = x - PIO4
    p = p * jnp.cos(xn) - w * q * jnp.sin(xn)
    return p * SQ2OPI / jnp.sqrt(x)


@jax.jit
def j0(z: ArrayLike) -> Array:
    """
    Bessel function of the first kind of order zero and a real argument
    - using the implementation from CEPHES, translated to Jax, to match scipy to machine precision.

    Reference:
    Cephes Mathematical Library.

    Args:
        z: The sampling point(s) at which the Bessel function of the first kind are
        computed.

    Returns:
        An array of shape `x.shape` containing the values of the Bessel function
    """
    z = jnp.asarray(z)
    (z,) = promote_dtypes_inexact(z)
    z_dtype = lax.dtype(z)

    if dtypes.issubdtype(z_dtype, complex):
        raise ValueError("complex input not supported.")

    return jnp.where(jnp.abs(z) < 5.0, j0_small(jnp.abs(z)), j0_large(jnp.abs(z)))


# POLYNOMIAL IMPLEMENTATION
def besseljy_debye(v, x):
    vmx = (v + x) * (v - x)
    vs = np.sqrt(vmx)
    sqvs = 1.0 / np.sqrt(vs)
    n = v * (-np.log(x / (v + vs))) - vs

    coef_Jn = np.sqrt(1.0 / (2 * np.pi)) * np.exp(-n) * sqvs
    coef_Yn = -np.sqrt(2.0 / np.pi) * np.exp(n) * sqvs

    p = v / vs
    p2 = v**2 / vmx

    Uk_Jn, Uk_Yn = Uk_poly_Jn(p, v, p2, x)
    return coef_Jn * Uk_Jn, coef_Yn * Uk_Yn


def Uk_poly_Jn(p, v, p2, x):

    return np.where(
        v > (5.0 + 1.00033 * x + 11.26 * np.cbrt(x)),
        Uk_poly10(p, v, p2),
        Uk_poly20(p, v, p2),
    )


def Uk_poly10(p, v, p2):
    Poly = Uk_poly10_eval(p2)
    return split_evalpoly(-p / v, Poly)


def Uk_poly10_eval(p2):
    u10 = np.polyval(
        (
            110.01714026924674,
            -13886.08975371704,
            308186.40461266245,
            -2.7856181280864547e6,
            1.3288767166421818e7,
            -3.7567176660763346e7,
            6.634451227472903e7,
            -7.410514821153265e7,
            5.095260249266464e7,
            -1.9706819118432228e7,
            3.284469853072038e6,
        ),
        p2,
    )
    u9 = np.polyval(
        (
            24.380529699556064,
            -2499.8304818112097,
            45218.76898136273,
            -331645.17248456355,
            1.2683652733216248e6,
            -2.8135632265865337e6,
            3.763271297656404e6,
            -2.998015918538107e6,
            1.3117636146629772e6,
            -242919.18790055133,
        ),
        p2,
    )
    u8 = np.polyval(
        (
            6.074042001273483,
            -493.91530477308805,
            7109.514302489364,
            -41192.65496889755,
            122200.46498301747,
            -203400.17728041555,
            192547.00123253153,
            -96980.59838863752,
            20204.29133096615,
        ),
        p2,
    )
    u7 = np.polyval(
        (
            1.7277275025844574,
            -108.09091978839466,
            1200.9029132163525,
            -5305.646978613403,
            11655.393336864534,
            -13586.550006434136,
            8061.722181737309,
            -1919.457662318407,
        ),
        p2,
    )
    u6 = np.polyval(
        (
            0.5725014209747314,
            -26.491430486951554,
            218.1905117442116,
            -699.5796273761325,
            1059.9904525279999,
            -765.2524681411817,
            212.57013003921713,
        ),
        p2,
    )
    u5 = np.polyval(
        (
            0.22710800170898438,
            -7.368794359479632,
            42.53499874538846,
            -91.81824154324002,
            84.63621767460073,
            -28.212072558200244,
        ),
        p2,
    )
    u4 = np.polyval(
        (
            0.112152099609375,
            -2.3640869140625,
            8.78912353515625,
            -11.207002616222994,
            4.669584423426247,
        ),
        p2,
    )
    u3 = np.polyval(
        (0.0732421875, -0.8912109375, 1.8464626736111112, -1.0258125964506173),
        p2,
    )
    u2 = np.polyval(
        (0.0703125, -0.4010416666666667, 0.3342013888888889),
        p2,
    )
    u1 = np.polyval(
        (0.125, -0.20833333333333334),
        p2,
    )
    return (1.0, u1, u2, u3, u4, u5, u6, u7, u8, u9, u10)


def Uk_poly20(p, v, p2):
    Poly = _Uk_poly20(p2)
    return split_evalpoly(-p / v, Poly)


def _Uk_poly20(p2):
    u20 = np.polyval(
        (
            3.646840080706556e10,
            -1.818726203851104e13,
            1.5613123930484672e15,
            -5.48403360388329e16,
            1.0461721131134344e18,
            -1.2483700995047234e19,
            1.0126774169536592e20,
            -5.8917941350694964e20,
            2.548961114664972e21,
            -8.405915817108351e21,
            2.1487414815055883e22,
            -4.302534303482379e22,
            6.783661642951883e22,
            -8.423222750084323e22,
            8.19433100543513e22,
            -6.173206302884415e22,
            3.528435843903409e22,
            -1.4787743528433614e22,
            4.285296082829494e21,
            -7.671943936729004e20,
            6.393286613940837e19,
        ),
        p2,
    )
    u19 = np.polyval(
        (
            3.8362551802304335e9,
            -1.7277040123529995e12,
            1.3412416915180639e14,
            -4.2619355104268985e15,
            7.351663610930971e16,
            -7.921651119323832e17,
            5.789887667664653e18,
            -3.025566598990372e19,
            1.1707490535797259e20,
            -3.434621399768417e20,
            7.756704953461136e20,
            -1.360203777284994e21,
            1.8571089321463453e21,
            -1.9677247077053125e21,
            1.6016898573693598e21,
            -9.824438427689858e20,
            4.392792200888712e20,
            -1.351217503435996e20,
            2.5563802960529236e19,
            -2.242438856186775e18,
        ),
        p2,
    )
    u18 = np.polyval(
        (
            4.259392165047669e8,
            -1.722832387173505e11,
            1.2030115826419191e13,
            -3.4396530474307594e14,
            5.335106978708839e15,
            -5.1605093193485224e16,
            3.37667624979061e17,
            -1.5736434765189599e18,
            5.402894876715982e18,
            -1.3970803516443374e19,
            2.757282981650519e19,
            -4.178861444656839e19,
            4.859942729324836e19,
            -4.301555703831444e19,
            2.846521225167657e19,
            -1.3639420410571592e19,
            4.47020096401231e18,
            -8.966114215270463e17,
            8.30195760673191e16,
        ),
        p2,
    )
    u17 = np.polyval(
        (
            5.0069589531988926e7,
            -1.8078220384658062e10,
            1.128709145410874e12,
            -2.886383763141476e13,
            4.0004445704303625e14,
            -3.4503855118462725e15,
            2.0064271476309532e16,
            -8.270945651585064e16,
            2.4960365126160426e17,
            -5.62631788074636e17,
            9.575335098169139e17,
            -1.2336116931960694e18,
            1.1961991142756308e18,
            -8.592577980317548e17,
            4.4347954614171904e17,
            -1.5552983504313904e17,
            3.3192764720355224e16,
            -3.254192619642669e15,
        ),
        p2,
    )
    u16 = np.polyval(
        (
            6.252951493434797e6,
            -2.0016469281917763e9,
            1.1099740513917902e11,
            -2.5215584749128545e12,
            3.100743647289646e13,
            -2.3665253045164925e14,
            1.2126758042503475e15,
            -4.3793258383640155e15,
            1.1486706978449752e16,
            -2.2268225133911144e16,
            3.213827526858624e16,
            -3.4447226006485144e16,
            2.705471130619708e16,
            -1.5129826322457682e16,
            5.705782159023671e15,
            -1.3010127235496995e15,
            1.3552215870309369e14,
        ),
        p2,
    )
    u15 = np.polyval(
        (
            832859.3040162893,
            -2.3455796352225152e8,
            1.1465754899448236e10,
            -2.2961937296824646e11,
            2.4850009280340854e12,
            -1.663482472489248e13,
            7.437312290867914e13,
            -2.3260483118893994e14,
            5.230548825784446e14,
            -8.57461032982895e14,
            1.0269551960827625e15,
            -8.894969398810265e14,
            5.4273966498765975e14,
            -2.213496387025252e14,
            5.417751075510605e13,
            -6.019723417234006e12,
        ),
        p2,
    )
    u14 = np.polyval(
        (
            118838.42625678326,
            -2.9188388122220814e7,
            1.2470092935127103e9,
            -2.1822927757529224e10,
            2.0591450323241e11,
            -1.1965528801961816e12,
            4.612725780849132e12,
            -1.2320491305598287e13,
            2.334836404458184e13,
            -3.166708858478516e13,
            3.056512551993532e13,
            -2.0516899410934438e13,
            9.109341185239898e12,
            -2.406297900028504e12,
            2.86464035717679e11,
        ),
        p2,
    )
    u13 = np.polyval(
        (
            18257.755474293175,
            -3.8718334425726123e6,
            1.43157876718889e8,
            -2.167164983223795e9,
            1.763473060683497e10,
            -8.786707217802327e10,
            2.879006499061506e11,
            -6.453648692453765e11,
            1.0081581068653821e12,
            -1.0983751560812233e12,
            8.192186695485773e11,
            -3.990961752244665e11,
            1.144982377320258e11,
            -1.4679261247695616e10,
        ),
        p2,
    )
    u12 = np.polyval(
        (
            3038.090510922384,
            -549842.3275722887,
            1.7395107553978164e7,
            -2.2510566188941526e8,
            1.5592798648792574e9,
            -6.563293792619285e9,
            1.79542137311556e10,
            -3.3026599749800724e10,
            4.1280185579753975e10,
            -3.4632043388158775e10,
            1.8688207509295826e10,
            -5.866481492051847e9,
            8.147890961183121e8,
        ),
        p2,
    )
    u11 = np.polyval(
        (
            551.3358961220206,
            -84005.4336030241,
            2.2437681779224495e6,
            -2.4474062725738727e7,
            1.420629077975331e8,
            -4.9588978427503026e8,
            1.1068428168230145e9,
            -1.6210805521083372e9,
            1.5535968995705802e9,
            -9.394623596815784e8,
            3.2557307418576574e8,
            -4.932925366450996e7,
        ),
        p2,
    )
    u10 = np.polyval(
        (
            110.01714026924674,
            -13886.08975371704,
            308186.40461266245,
            -2.7856181280864547e6,
            1.3288767166421818e7,
            -3.7567176660763346e7,
            6.634451227472903e7,
            -7.410514821153265e7,
            5.095260249266464e7,
            -1.9706819118432228e7,
            3.284469853072038e6,
        ),
        p2,
    )
    u9 = np.polyval(
        (
            24.380529699556064,
            -2499.8304818112097,
            45218.76898136273,
            -331645.17248456355,
            1.2683652733216248e6,
            -2.8135632265865337e6,
            3.763271297656404e6,
            -2.998015918538107e6,
            1.3117636146629772e6,
            -242919.18790055133,
        ),
        p2,
    )
    u8 = np.polyval(
        (
            6.074042001273483,
            -493.91530477308805,
            7109.514302489364,
            -41192.65496889755,
            122200.46498301747,
            -203400.17728041555,
            192547.00123253153,
            -96980.59838863752,
            20204.29133096615,
        ),
        p2,
    )
    u7 = np.polyval(
        (
            1.7277275025844574,
            -108.09091978839466,
            1200.9029132163525,
            -5305.646978613403,
            11655.393336864534,
            -13586.550006434136,
            8061.722181737309,
            -1919.457662318407,
        ),
        p2,
    )
    u6 = np.polyval(
        (
            0.5725014209747314,
            -26.491430486951554,
            218.1905117442116,
            -699.5796273761325,
            1059.9904525279999,
            -765.2524681411817,
            212.57013003921713,
        ),
        p2,
    )
    u5 = np.polyval(
        (
            0.22710800170898438,
            -7.368794359479632,
            42.53499874538846,
            -91.81824154324002,
            84.63621767460073,
            -28.212072558200244,
        ),
        p2,
    )
    u4 = np.polyval(
        (
            0.112152099609375,
            -2.3640869140625,
            8.78912353515625,
            -11.207002616222994,
            4.669584423426247,
        ),
        p2,
    )
    u3 = np.polyval(
        (0.0732421875, -0.8912109375, 1.8464626736111112, -1.0258125964506173),
        p2,
    )
    u2 = np.polyval(
        (0.0703125, -0.4010416666666667, 0.3342013888888889),
        p2,
    )
    u1 = np.polyval(
        (0.125, -0.20833333333333334),
        p2,
    )
    return (
        1.0,
        u1,
        u2,
        u3,
        u4,
        u5,
        u6,
        u7,
        u8,
        u9,
        u10,
        u11,
        u12,
        u13,
        u14,
        u15,
        u16,
        u17,
        u18,
        u19,
        u20,
    )


def split_evalpoly(x, P):
    # polynomial P must have an even number of terms
    N = len(P)
    xx = x * x

    out = P[-1]
    out2 = P[-2]

    for i in range(N - 3, 0, -2):
        out = xx * out + P[i]
        out2 = xx * out2 + P[i - 1]

    if N % 2 == 0:
        out *= x
        return (out2 - out, out2 + out)
    else:
        out = xx * out + P[0]
        out2 *= x
        return (out - out2, out2 + out)


def besselj_power_series(x, v, n_iter=100):
    """ """
    out = jnp.zeros_like(x)
    a = jnp.power(x / 2, v) / jax.scipy.special.gamma(v + 1.0)
    t2 = jnp.square(x / 2)

    def body_func(i, carry):
        """ """
        out, a = carry
        out += a
        a *= -t2 / ((v + i + 1) * (i + 1))
        return (out, a)

    # Loop
    return jax.lax.fori_loop(0, n_iter, body_func, (out, a))[0]


@functools.partial(jax.jit, static_argnames=["v"])
def bessel_jn(z: ArrayLike, v: int) -> Array:
    """Bessel function of the first kind of integer order > 2 and real argument.
    Calculates higher order Bessel functions using the recurrence relation.
    This is numerically accurate to machine precision wrt the scipy implementation for
    z >~2, while higher order Bessel functions can be ~ 1e-10 wrt scipy for small z.
    Reference:
    Cephes Mathematical Library.
    Args:
      z: The sampling point(s) at which the Bessel function of the first kind are
        computed.
      v: The order (int) of the Bessel function.
    Returns:
      An array of shape `(v+1, *z.shape)` containing the values of the Bessel
      function of orders 0, 1, ..., v. The return type matches the type of `z`.
    Raises:
      TypeError if `v` is not integer.
      ValueError if elements of array `z` are not float.
    """
    z = jnp.asarray(z)
    (z,) = promote_dtypes_inexact(z)
    z_dtype = lax.dtype(z)
    if dtypes.issubdtype(z_dtype, complex):
        raise ValueError("complex input not supported.")

    # use recurrence relation J_v+1(z) = 2 v/z J_v(z) - J_v-1(z) recursively
    def body(i, carry):
        jnm1, jn = carry
        jnplus = (2 * i) / z * jn - jnm1
        return (jn, jnplus)

    jn = jnp.select(
        [v == 0, v == 1, v > 1],
        [j0(z), j1(z), jax.lax.fori_loop(1, v, body, (j0(z), j1(z)))[-1]],
    )
    return jnp.where(z < 1e-5, 0.0, jn)
